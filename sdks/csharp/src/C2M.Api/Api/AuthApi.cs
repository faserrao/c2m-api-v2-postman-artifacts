// <auto-generated>
/*
 * C2M API v2 - Auth Overlay
 *
 * API for submitting documents with various routing options
 *
 * The version of the OpenAPI document: 2.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using C2M.Api.Client;
using C2M.Api.Model;
using System.Diagnostics.CodeAnalysis;

namespace C2M.Api.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IAuthApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        AuthApiEvents Events { get; }

        /// <summary>
        /// Issue or rotate a long-term token
        /// </summary>
        /// <remarks>
        /// Issues a long-term token (e.g., 30-90 days) for automation or server-to-server use. Requires step-up authentication. Choose one of the supported grant types:  - &#x60;client_credentials&#x60; + &#x60;client_secret&#x60; - &#x60;client_credentials&#x60; + one-time &#x60;otp_code&#x60; - &#x60;assertion&#x60; (e.g., signed JWT by your private key) - Or an existing short-term token with the &#x60;tokens:write&#x60; scope  Only one mechanism is required per call. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="longTokenRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IIssueLongTermTokenApiResponse"/>&gt;</returns>
        Task<IIssueLongTermTokenApiResponse> IssueLongTermTokenAsync(LongTokenRequest longTokenRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Issue or rotate a long-term token
        /// </summary>
        /// <remarks>
        /// Issues a long-term token (e.g., 30-90 days) for automation or server-to-server use. Requires step-up authentication. Choose one of the supported grant types:  - &#x60;client_credentials&#x60; + &#x60;client_secret&#x60; - &#x60;client_credentials&#x60; + one-time &#x60;otp_code&#x60; - &#x60;assertion&#x60; (e.g., signed JWT by your private key) - Or an existing short-term token with the &#x60;tokens:write&#x60; scope  Only one mechanism is required per call. 
        /// </remarks>
        /// <param name="longTokenRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IIssueLongTermTokenApiResponse"/>?&gt;</returns>
        Task<IIssueLongTermTokenApiResponse?> IssueLongTermTokenOrDefaultAsync(LongTokenRequest longTokenRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Issue a short-term access token
        /// </summary>
        /// <remarks>
        /// Exchange a valid long-term token for a short-lived JWT (e.g., 15 minutes). The long-term token must be sent in the Authorization header as &#x60;Bearer &lt;long_token&gt;&#x60;. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="shortTokenRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IIssueShortTermTokenApiResponse"/>&gt;</returns>
        Task<IIssueShortTermTokenApiResponse> IssueShortTermTokenAsync(Option<ShortTokenRequest> shortTokenRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Issue a short-term access token
        /// </summary>
        /// <remarks>
        /// Exchange a valid long-term token for a short-lived JWT (e.g., 15 minutes). The long-term token must be sent in the Authorization header as &#x60;Bearer &lt;long_token&gt;&#x60;. 
        /// </remarks>
        /// <param name="shortTokenRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IIssueShortTermTokenApiResponse"/>?&gt;</returns>
        Task<IIssueShortTermTokenApiResponse?> IssueShortTermTokenOrDefaultAsync(Option<ShortTokenRequest> shortTokenRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Revoke a token
        /// </summary>
        /// <remarks>
        /// Revokes a short- or long-term token by its &#x60;tokenId&#x60;. Idempotent.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenId">The token ID to revoke</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRevokeTokenApiResponse"/>&gt;</returns>
        Task<IRevokeTokenApiResponse> RevokeTokenAsync(string tokenId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Revoke a token
        /// </summary>
        /// <remarks>
        /// Revokes a short- or long-term token by its &#x60;tokenId&#x60;. Idempotent.
        /// </remarks>
        /// <param name="tokenId">The token ID to revoke</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRevokeTokenApiResponse"/>?&gt;</returns>
        Task<IRevokeTokenApiResponse?> RevokeTokenOrDefaultAsync(string tokenId, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IIssueLongTermTokenApiResponse"/>
    /// </summary>
    public interface IIssueLongTermTokenApiResponse : C2M.Api.Client.IApiResponse, ICreated<C2M.Api.Model.LongTokenResponse?>, IBadRequest<C2M.Api.Model.AuthError?>, IUnauthorized<C2M.Api.Model.AuthError?>, IForbidden<C2M.Api.Model.AuthError?>, ITooManyRequests<C2M.Api.Model.AuthError?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }
    }

    /// <summary>
    /// The <see cref="IIssueShortTermTokenApiResponse"/>
    /// </summary>
    public interface IIssueShortTermTokenApiResponse : C2M.Api.Client.IApiResponse, ICreated<C2M.Api.Model.ShortTokenResponse?>, IBadRequest<C2M.Api.Model.AuthError?>, IUnauthorized<C2M.Api.Model.AuthError?>, ITooManyRequests<C2M.Api.Model.AuthError?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }
    }

    /// <summary>
    /// The <see cref="IRevokeTokenApiResponse"/>
    /// </summary>
    public interface IRevokeTokenApiResponse : C2M.Api.Client.IApiResponse, IUnauthorized<C2M.Api.Model.AuthError?>, INotFound<C2M.Api.Model.AuthError?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class AuthApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnIssueLongTermToken;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorIssueLongTermToken;

        internal void ExecuteOnIssueLongTermToken(AuthApi.IssueLongTermTokenApiResponse apiResponse)
        {
            OnIssueLongTermToken?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorIssueLongTermToken(Exception exception)
        {
            OnErrorIssueLongTermToken?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnIssueShortTermToken;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorIssueShortTermToken;

        internal void ExecuteOnIssueShortTermToken(AuthApi.IssueShortTermTokenApiResponse apiResponse)
        {
            OnIssueShortTermToken?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorIssueShortTermToken(Exception exception)
        {
            OnErrorIssueShortTermToken?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRevokeToken;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRevokeToken;

        internal void ExecuteOnRevokeToken(AuthApi.RevokeTokenApiResponse apiResponse)
        {
            OnRevokeToken?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRevokeToken(Exception exception)
        {
            OnErrorRevokeToken?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class AuthApi : IAuthApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<AuthApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public AuthApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="OauthTokenProvider"/>
        /// </summary>
        public TokenProvider<OAuthToken> OauthTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="AuthApi"/> class.
        /// </summary>
        /// <returns></returns>
        public AuthApi(ILogger<AuthApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, AuthApiEvents authApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider,
            TokenProvider<BearerToken> bearerTokenProvider,
            TokenProvider<OAuthToken> oauthTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<AuthApi>();
            HttpClient = httpClient;
            Events = authApiEvents;
            ApiKeyProvider = apiKeyProvider;
            BearerTokenProvider = bearerTokenProvider;
            OauthTokenProvider = oauthTokenProvider;
        }

        partial void FormatIssueLongTermToken(LongTokenRequest longTokenRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="longTokenRequest"></param>
        /// <returns></returns>
        private void ValidateIssueLongTermToken(LongTokenRequest longTokenRequest)
        {
            if (longTokenRequest == null)
                throw new ArgumentNullException(nameof(longTokenRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="longTokenRequest"></param>
        private void AfterIssueLongTermTokenDefaultImplementation(IIssueLongTermTokenApiResponse apiResponseLocalVar, LongTokenRequest longTokenRequest)
        {
            bool suppressDefaultLog = false;
            AfterIssueLongTermToken(ref suppressDefaultLog, apiResponseLocalVar, longTokenRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="longTokenRequest"></param>
        partial void AfterIssueLongTermToken(ref bool suppressDefaultLog, IIssueLongTermTokenApiResponse apiResponseLocalVar, LongTokenRequest longTokenRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="longTokenRequest"></param>
        private void OnErrorIssueLongTermTokenDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, LongTokenRequest longTokenRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorIssueLongTermToken(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, longTokenRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="longTokenRequest"></param>
        partial void OnErrorIssueLongTermToken(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, LongTokenRequest longTokenRequest);

        /// <summary>
        /// Issue or rotate a long-term token Issues a long-term token (e.g., 30-90 days) for automation or server-to-server use. Requires step-up authentication. Choose one of the supported grant types:  - &#x60;client_credentials&#x60; + &#x60;client_secret&#x60; - &#x60;client_credentials&#x60; + one-time &#x60;otp_code&#x60; - &#x60;assertion&#x60; (e.g., signed JWT by your private key) - Or an existing short-term token with the &#x60;tokens:write&#x60; scope  Only one mechanism is required per call. 
        /// </summary>
        /// <param name="longTokenRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IIssueLongTermTokenApiResponse"/>&gt;</returns>
        public async Task<IIssueLongTermTokenApiResponse?> IssueLongTermTokenOrDefaultAsync(LongTokenRequest longTokenRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await IssueLongTermTokenAsync(longTokenRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Issue or rotate a long-term token Issues a long-term token (e.g., 30-90 days) for automation or server-to-server use. Requires step-up authentication. Choose one of the supported grant types:  - &#x60;client_credentials&#x60; + &#x60;client_secret&#x60; - &#x60;client_credentials&#x60; + one-time &#x60;otp_code&#x60; - &#x60;assertion&#x60; (e.g., signed JWT by your private key) - Or an existing short-term token with the &#x60;tokens:write&#x60; scope  Only one mechanism is required per call. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="longTokenRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IIssueLongTermTokenApiResponse"/>&gt;</returns>
        public async Task<IIssueLongTermTokenApiResponse> IssueLongTermTokenAsync(LongTokenRequest longTokenRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateIssueLongTermToken(longTokenRequest);

                FormatIssueLongTermToken(longTokenRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/auth/tokens/long"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/auth/tokens/long");

                    httpRequestMessageLocalVar.Content = (longTokenRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(longTokenRequest, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("X-Client-Id", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<IssueLongTermTokenApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<IssueLongTermTokenApiResponse>();
                        IssueLongTermTokenApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/auth/tokens/long", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterIssueLongTermTokenDefaultImplementation(apiResponseLocalVar, longTokenRequest);

                        Events.ExecuteOnIssueLongTermToken(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorIssueLongTermTokenDefaultImplementation(e, "/auth/tokens/long", uriBuilderLocalVar.Path, longTokenRequest);
                Events.ExecuteOnErrorIssueLongTermToken(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="IssueLongTermTokenApiResponse"/>
        /// </summary>
        public partial class IssueLongTermTokenApiResponse : C2M.Api.Client.ApiResponse, IIssueLongTermTokenApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<IssueLongTermTokenApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="IssueLongTermTokenApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public IssueLongTermTokenApiResponse(ILogger<IssueLongTermTokenApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="IssueLongTermTokenApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public IssueLongTermTokenApiResponse(ILogger<IssueLongTermTokenApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public C2M.Api.Model.LongTokenResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<C2M.Api.Model.LongTokenResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out C2M.Api.Model.LongTokenResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public C2M.Api.Model.AuthError? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<C2M.Api.Model.AuthError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out C2M.Api.Model.AuthError? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public C2M.Api.Model.AuthError? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<C2M.Api.Model.AuthError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out C2M.Api.Model.AuthError? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public C2M.Api.Model.AuthError? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<C2M.Api.Model.AuthError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out C2M.Api.Model.AuthError? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public C2M.Api.Model.AuthError? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<C2M.Api.Model.AuthError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out C2M.Api.Model.AuthError? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatIssueShortTermToken(Option<ShortTokenRequest> shortTokenRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="shortTokenRequest"></param>
        /// <returns></returns>
        private void ValidateIssueShortTermToken(Option<ShortTokenRequest> shortTokenRequest)
        {
            if (shortTokenRequest.IsSet && shortTokenRequest.Value == null)
                throw new ArgumentNullException(nameof(shortTokenRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="shortTokenRequest"></param>
        private void AfterIssueShortTermTokenDefaultImplementation(IIssueShortTermTokenApiResponse apiResponseLocalVar, Option<ShortTokenRequest> shortTokenRequest)
        {
            bool suppressDefaultLog = false;
            AfterIssueShortTermToken(ref suppressDefaultLog, apiResponseLocalVar, shortTokenRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="shortTokenRequest"></param>
        partial void AfterIssueShortTermToken(ref bool suppressDefaultLog, IIssueShortTermTokenApiResponse apiResponseLocalVar, Option<ShortTokenRequest> shortTokenRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="shortTokenRequest"></param>
        private void OnErrorIssueShortTermTokenDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<ShortTokenRequest> shortTokenRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorIssueShortTermToken(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, shortTokenRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="shortTokenRequest"></param>
        partial void OnErrorIssueShortTermToken(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<ShortTokenRequest> shortTokenRequest);

        /// <summary>
        /// Issue a short-term access token Exchange a valid long-term token for a short-lived JWT (e.g., 15 minutes). The long-term token must be sent in the Authorization header as &#x60;Bearer &lt;long_token&gt;&#x60;. 
        /// </summary>
        /// <param name="shortTokenRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IIssueShortTermTokenApiResponse"/>&gt;</returns>
        public async Task<IIssueShortTermTokenApiResponse?> IssueShortTermTokenOrDefaultAsync(Option<ShortTokenRequest> shortTokenRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await IssueShortTermTokenAsync(shortTokenRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Issue a short-term access token Exchange a valid long-term token for a short-lived JWT (e.g., 15 minutes). The long-term token must be sent in the Authorization header as &#x60;Bearer &lt;long_token&gt;&#x60;. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="shortTokenRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IIssueShortTermTokenApiResponse"/>&gt;</returns>
        public async Task<IIssueShortTermTokenApiResponse> IssueShortTermTokenAsync(Option<ShortTokenRequest> shortTokenRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateIssueShortTermToken(shortTokenRequest);

                FormatIssueShortTermToken(shortTokenRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/auth/tokens/short"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/auth/tokens/short");

                    if (shortTokenRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (shortTokenRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(shortTokenRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<IssueShortTermTokenApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<IssueShortTermTokenApiResponse>();
                        IssueShortTermTokenApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/auth/tokens/short", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterIssueShortTermTokenDefaultImplementation(apiResponseLocalVar, shortTokenRequest);

                        Events.ExecuteOnIssueShortTermToken(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorIssueShortTermTokenDefaultImplementation(e, "/auth/tokens/short", uriBuilderLocalVar.Path, shortTokenRequest);
                Events.ExecuteOnErrorIssueShortTermToken(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="IssueShortTermTokenApiResponse"/>
        /// </summary>
        public partial class IssueShortTermTokenApiResponse : C2M.Api.Client.ApiResponse, IIssueShortTermTokenApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<IssueShortTermTokenApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="IssueShortTermTokenApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public IssueShortTermTokenApiResponse(ILogger<IssueShortTermTokenApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="IssueShortTermTokenApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public IssueShortTermTokenApiResponse(ILogger<IssueShortTermTokenApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public C2M.Api.Model.ShortTokenResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<C2M.Api.Model.ShortTokenResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out C2M.Api.Model.ShortTokenResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public C2M.Api.Model.AuthError? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<C2M.Api.Model.AuthError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out C2M.Api.Model.AuthError? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public C2M.Api.Model.AuthError? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<C2M.Api.Model.AuthError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out C2M.Api.Model.AuthError? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public C2M.Api.Model.AuthError? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<C2M.Api.Model.AuthError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out C2M.Api.Model.AuthError? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRevokeToken(ref string tokenId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="tokenId"></param>
        /// <returns></returns>
        private void ValidateRevokeToken(string tokenId)
        {
            if (tokenId == null)
                throw new ArgumentNullException(nameof(tokenId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tokenId"></param>
        private void AfterRevokeTokenDefaultImplementation(IRevokeTokenApiResponse apiResponseLocalVar, string tokenId)
        {
            bool suppressDefaultLog = false;
            AfterRevokeToken(ref suppressDefaultLog, apiResponseLocalVar, tokenId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tokenId"></param>
        partial void AfterRevokeToken(ref bool suppressDefaultLog, IRevokeTokenApiResponse apiResponseLocalVar, string tokenId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="tokenId"></param>
        private void OnErrorRevokeTokenDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string tokenId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorRevokeToken(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, tokenId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="tokenId"></param>
        partial void OnErrorRevokeToken(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string tokenId);

        /// <summary>
        /// Revoke a token Revokes a short- or long-term token by its &#x60;tokenId&#x60;. Idempotent.
        /// </summary>
        /// <param name="tokenId">The token ID to revoke</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRevokeTokenApiResponse"/>&gt;</returns>
        public async Task<IRevokeTokenApiResponse?> RevokeTokenOrDefaultAsync(string tokenId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RevokeTokenAsync(tokenId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Revoke a token Revokes a short- or long-term token by its &#x60;tokenId&#x60;. Idempotent.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenId">The token ID to revoke</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRevokeTokenApiResponse"/>&gt;</returns>
        public async Task<IRevokeTokenApiResponse> RevokeTokenAsync(string tokenId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateRevokeToken(tokenId);

                FormatRevokeToken(ref tokenId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/auth/tokens/{tokenId}/revoke"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/auth/tokens/{tokenId}/revoke");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BtokenId%7D", Uri.EscapeDataString(tokenId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    OAuthToken oauthTokenLocalVar2 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar2);

                    oauthTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<RevokeTokenApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RevokeTokenApiResponse>();
                        RevokeTokenApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/auth/tokens/{tokenId}/revoke", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterRevokeTokenDefaultImplementation(apiResponseLocalVar, tokenId);

                        Events.ExecuteOnRevokeToken(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRevokeTokenDefaultImplementation(e, "/auth/tokens/{tokenId}/revoke", uriBuilderLocalVar.Path, tokenId);
                Events.ExecuteOnErrorRevokeToken(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RevokeTokenApiResponse"/>
        /// </summary>
        public partial class RevokeTokenApiResponse : C2M.Api.Client.ApiResponse, IRevokeTokenApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RevokeTokenApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RevokeTokenApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RevokeTokenApiResponse(ILogger<RevokeTokenApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="RevokeTokenApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RevokeTokenApiResponse(ILogger<RevokeTokenApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public C2M.Api.Model.AuthError? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<C2M.Api.Model.AuthError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out C2M.Api.Model.AuthError? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public C2M.Api.Model.AuthError? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<C2M.Api.Model.AuthError>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out C2M.Api.Model.AuthError? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
