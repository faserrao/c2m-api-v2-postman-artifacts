/* tslint:disable */
/* eslint-disable */
/**
 * C2M API v2
 * API for submitting mailing jobs with various document routing options
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AchDetails {
    'routingNumber': string;
    'accountNumber': string;
    'checkDigit': number;
}
export interface AchPayment {
    'achDetails': AchDetails;
}
export interface Address {
    'firstName': string;
    'lastName': string;
    'address1': string;
    'city': string;
    'state': string;
    'zip': string;
    'country': string;
    'address2'?: string;
    'address3'?: string;
    'foo1'?: string;
    'foo2'?: string;
}
export interface AuthError {
    /**
     * OAuth-style error code
     */
    'code': string;
    /**
     * Human-readable error message
     */
    'message': string;
    /**
     * Additional error details
     */
    'details'?: object;
}

export const CardType = {
    Visa: 'visa',
    Mastercard: 'mastercard',
    Discover: 'discover',
    AmericanExpress: 'americanExpress'
} as const;

export type CardType = typeof CardType[keyof typeof CardType];


export interface CreditAmount {
    'amount': number;
    'currency': CreditAmountCurrencyEnum;
}

export const CreditAmountCurrencyEnum = {
    Usd: 'USD',
    Eur: 'EUR',
    Gbp: 'GBP',
    Cad: 'CAD',
    Aud: 'AUD'
} as const;

export type CreditAmountCurrencyEnum = typeof CreditAmountCurrencyEnum[keyof typeof CreditAmountCurrencyEnum];

export interface CreditCardDetails {
    'cardType': CreditCardDetailsCardTypeEnum;
    'cardNumber': string;
    'expirationDate': ExpirationDate;
    'cvv': number;
}

export const CreditCardDetailsCardTypeEnum = {
    Visa: 'visa',
    Mastercard: 'mastercard',
    Discover: 'discover',
    AmericanExpress: 'americanExpress'
} as const;

export type CreditCardDetailsCardTypeEnum = typeof CreditCardDetailsCardTypeEnum[keyof typeof CreditCardDetailsCardTypeEnum];

export interface CreditCardPayment {
    'creditCardDetails': CreditCardDetails;
}

export const Currency = {
    Usd: 'USD',
    Eur: 'EUR',
    Gbp: 'GBP',
    Cad: 'CAD',
    Aud: 'AUD'
} as const;

export type Currency = typeof Currency[keyof typeof Currency];


/**
 * @type DocSourceAll
 */
export type DocSourceAll = DocSourceStandard | DocSourceZipFile;

/**
 * @type DocSourceStandard
 */
export type DocSourceStandard = RequestIdSource | number | string;

/**
 * @type DocSourceZipFile
 */
export type DocSourceZipFile = ZipDocumentIdSource | ZipRequestIdSource;


export const ErrorCode = {
    MissingRequiredField: 'MISSING_REQUIRED_FIELD',
    InvalidOneof: 'INVALID_ONEOF',
    InvalidJson: 'INVALID_JSON',
    MissingAuthHeader: 'MISSING_AUTH_HEADER',
    InvalidToken: 'INVALID_TOKEN',
    ExpiredToken: 'EXPIRED_TOKEN',
    InsufficientPermissions: 'INSUFFICIENT_PERMISSIONS',
    AccountSuspended: 'ACCOUNT_SUSPENDED',
    JobNotFound: 'JOB_NOT_FOUND',
    ResourceNotFound: 'RESOURCE_NOT_FOUND',
    InvalidEnumValue: 'INVALID_ENUM_VALUE',
    MutualExclusionViolation: 'MUTUAL_EXCLUSION_VIOLATION',
    InvalidFormat: 'INVALID_FORMAT',
    ServerError: 'SERVER_ERROR',
    DatabaseError: 'DATABASE_ERROR',
    ExternalServiceError: 'EXTERNAL_SERVICE_ERROR'
} as const;

export type ErrorCode = typeof ErrorCode[keyof typeof ErrorCode];


export interface ErrorResponse {
    'errorType': ErrorResponseErrorTypeEnum;
    'errorMessage': string;
    'errorCode': ErrorResponseErrorCodeEnum;
    'errorDetails'?: string;
    'errorTrackingId'?: string;
}

export const ErrorResponseErrorTypeEnum = {
    ValidationError: 'ValidationError',
    AuthenticationError: 'AuthenticationError',
    AuthorizationError: 'AuthorizationError',
    ResourceNotFoundError: 'ResourceNotFoundError',
    ServerError: 'ServerError'
} as const;

export type ErrorResponseErrorTypeEnum = typeof ErrorResponseErrorTypeEnum[keyof typeof ErrorResponseErrorTypeEnum];
export const ErrorResponseErrorCodeEnum = {
    MissingRequiredField: 'MISSING_REQUIRED_FIELD',
    InvalidOneof: 'INVALID_ONEOF',
    InvalidJson: 'INVALID_JSON',
    MissingAuthHeader: 'MISSING_AUTH_HEADER',
    InvalidToken: 'INVALID_TOKEN',
    ExpiredToken: 'EXPIRED_TOKEN',
    InsufficientPermissions: 'INSUFFICIENT_PERMISSIONS',
    AccountSuspended: 'ACCOUNT_SUSPENDED',
    JobNotFound: 'JOB_NOT_FOUND',
    ResourceNotFound: 'RESOURCE_NOT_FOUND',
    InvalidEnumValue: 'INVALID_ENUM_VALUE',
    MutualExclusionViolation: 'MUTUAL_EXCLUSION_VIOLATION',
    InvalidFormat: 'INVALID_FORMAT',
    ServerError: 'SERVER_ERROR',
    DatabaseError: 'DATABASE_ERROR',
    ExternalServiceError: 'EXTERNAL_SERVICE_ERROR'
} as const;

export type ErrorResponseErrorCodeEnum = typeof ErrorResponseErrorCodeEnum[keyof typeof ErrorResponseErrorCodeEnum];


export const ErrorType = {
    ValidationError: 'ValidationError',
    AuthenticationError: 'AuthenticationError',
    AuthorizationError: 'AuthorizationError',
    ResourceNotFoundError: 'ResourceNotFoundError',
    ServerError: 'ServerError'
} as const;

export type ErrorType = typeof ErrorType[keyof typeof ErrorType];


export interface ExpirationDate {
    'month': number;
    'year': number;
}
export interface InvoiceDetails {
    'invoiceNumber': string;
    'amountDue': number;
}
export interface InvoicePayment {
    'invoiceDetails': InvoiceDetails;
}
export interface JobOptions {
    'documentClass': string;
    'layout': string;
    'productionTime': string;
    'envelope': string;
    'color': string;
    'paperType': string;
    'printOption': string;
    'mailClass': string;
}
/**
 * One of several credential mechanisms must be provided.
 */
export interface LongTokenRequest {
    /**
     * The authentication grant type
     */
    'grant_type': LongTokenRequestGrantTypeEnum;
    /**
     * Client identifier issued by Click2Mail
     */
    'client_id': string;
    /**
     * Required if using client_credentials with secret
     */
    'client_secret'?: string;
    /**
     * Required if your policy mandates OTP for issuance
     */
    'otp_code'?: string;
    /**
     * Required when grant_type=assertion
     */
    'assertion_type'?: string;
    /**
     * Signed JWT or other accepted assertion
     */
    'assertion'?: string;
    /**
     * Scopes to assign to the long-term token
     */
    'scopes'?: Array<string>;
    /**
     * Requested lifetime (1 hour - 90 days). Server may clamp.
     */
    'ttl_seconds'?: number;
}

export const LongTokenRequestGrantTypeEnum = {
    ClientCredentials: 'client_credentials',
    Assertion: 'assertion'
} as const;

export type LongTokenRequestGrantTypeEnum = typeof LongTokenRequestGrantTypeEnum[keyof typeof LongTokenRequestGrantTypeEnum];

export interface LongTokenResponse {
    'token_type': LongTokenResponseTokenTypeEnum;
    /**
     * Long-lived token (opaque or JWT depending on deployment)
     */
    'access_token': string;
    /**
     * Lifetime in seconds
     */
    'expires_in': number;
    /**
     * ISO 8601 timestamp of expiration
     */
    'expires_at': string;
    /**
     * Granted scopes
     */
    'scopes'?: Array<string>;
    /**
     * Server-issued identifier for this token
     */
    'token_id'?: string;
}

export const LongTokenResponseTokenTypeEnum = {
    Bearer: 'Bearer'
} as const;

export type LongTokenResponseTokenTypeEnum = typeof LongTokenResponseTokenTypeEnum[keyof typeof LongTokenResponseTokenTypeEnum];

export interface MergeByRequestId {
    'requestId': number;
    'filename'?: string;
}
/**
 * @type MergeDocumentRef
 */
export type MergeDocumentRef = MergeByRequestId | number;

export interface MultiDocJobItem {
    'jobTemplate'?: string;
    'docSourceAll': DocSourceAll;
    'recipientAddressSource': RecipientAddressSource;
}
export interface MultiZipJobItem {
    'jobTemplate'?: string;
    'docSourceZipFile': DocSourceZipFile;
    'recipientAddressSource': RecipientAddressSource;
}
/**
 * @type PaymentDetails
 */
export type PaymentDetails = AchPayment | CreditCardPayment | InvoicePayment | UserCreditPayment;

export interface PdfSplitJobItemNoAddress {
    'startPage': number;
    'endPage': number;
}
export interface PdfSplitJobItemWithAddress {
    'startPage': number;
    'endPage': number;
    'recipientAddressSource': RecipientAddressSource;
}
export interface RecipientAddressByList {
    'mappingId'?: number;
    'addressList': Array<Address>;
    'addressListName'?: string;
}
export interface RecipientAddressBySingle {
    'mappingId'?: number;
    'singleAddress': Address;
    'addressName'?: string;
}
/**
 * @type RecipientAddressSource
 */
export type RecipientAddressSource = RecipientAddressByList | RecipientAddressBySingle | number;

export interface RequestIdSource {
    'requestId': number;
    'filename'?: string;
}
export interface ReturnAddress {
    'firstName': string;
    'lastName': string;
    'address1': string;
    'city': string;
    'state': string;
    'zip': string;
    'country': string;
    'address2'?: string;
    'address3'?: string;
}
export interface ShortTokenRequest {
    /**
     * Optional if the long-term token is provided in Authorization header
     */
    'long_token'?: string;
    /**
     * Optional scope narrowing; defaults to the long-term token\'s scopes
     */
    'scopes'?: Array<string>;
}
export interface ShortTokenResponse {
    'token_type': ShortTokenResponseTokenTypeEnum;
    /**
     * Short-lived JWT
     */
    'access_token': string;
    /**
     * Lifetime in seconds (e.g., 900 for 15 minutes)
     */
    'expires_in': number;
    /**
     * ISO 8601 timestamp of expiration
     */
    'expires_at': string;
    /**
     * Granted scopes
     */
    'scopes'?: Array<string>;
    /**
     * Server-issued identifier for this token
     */
    'token_id'?: string;
}

export const ShortTokenResponseTokenTypeEnum = {
    Bearer: 'Bearer'
} as const;

export type ShortTokenResponseTokenTypeEnum = typeof ShortTokenResponseTokenTypeEnum[keyof typeof ShortTokenResponseTokenTypeEnum];

export interface StandardResponse {
    'status'?: string;
    'message'?: string;
    'requestId'?: string;
}
export interface SubmitMultiDocMergeParams {
    'jobTemplate'?: string;
    'mergeDocumentSource': Array<MergeDocumentRef>;
    'recipientAddressSource': RecipientAddressSource;
    'paymentDetails'?: PaymentDetails;
    'returnAddress'?: ReturnAddress;
    'jobOptions'?: JobOptions;
    'tags'?: Array<string>;
}
export interface SubmitMultiDocParams {
    'jobTemplate'?: string;
    'multiDocJobs': Array<MultiDocJobItem>;
    'paymentDetails'?: PaymentDetails;
    'tags'?: Array<string>;
}
export interface SubmitMultiZipAddressCaptureParams {
    'jobTemplate'?: string;
    'zipDocumentSource': ZipDocumentSource;
    'paymentDetails'?: PaymentDetails;
    'returnAddress'?: ReturnAddress;
    'jobOptions'?: JobOptions;
    'tags'?: Array<string>;
}
export interface SubmitMultiZipParams {
    'jobTemplate'?: string;
    'multiZipJobs': Array<MultiZipJobItem>;
    'paymentDetails'?: PaymentDetails;
    'tags'?: Array<string>;
}
export interface SubmitSingleDocParams {
    'jobTemplate'?: string;
    'docSourceAll': DocSourceAll;
    'recipientAddressSource': RecipientAddressSource;
    'paymentDetails'?: PaymentDetails;
    'returnAddress'?: ReturnAddress;
    'jobOptions'?: JobOptions;
    'tags'?: Array<string>;
}
export interface SubmitSinglePdfAddressCaptureParams {
    'jobTemplate'?: string;
    'docSourceStandard': DocSourceStandard;
    'paymentDetails'?: PaymentDetails;
    'returnAddress'?: ReturnAddress;
    'jobOptions'?: JobOptions;
    'tags'?: Array<string>;
}
export interface SubmitSinglePdfSplitAddressCaptureParams {
    'jobTemplate'?: string;
    'docSourceStandard': DocSourceStandard;
    'pdfSplitJobsNoAddress': Array<PdfSplitJobItemNoAddress>;
    'paymentDetails'?: PaymentDetails;
    'returnAddress'?: ReturnAddress;
    'jobOptions'?: JobOptions;
    'tags'?: Array<string>;
}
export interface SubmitSinglePdfSplitParams {
    'jobTemplate'?: string;
    'docSourceStandard': DocSourceStandard;
    'pdfSplitJobsWithAddress': Array<PdfSplitJobItemWithAddress>;
    'paymentDetails'?: PaymentDetails;
    'returnAddress'?: ReturnAddress;
    'jobOptions'?: JobOptions;
    'tags'?: Array<string>;
}
export interface UserCreditPayment {
    'creditAmount': CreditAmount;
}
export interface ZipDocumentIdSource {
    'zipDocumentId': number;
    'filename': string;
}
/**
 * @type ZipDocumentSource
 */
export type ZipDocumentSource = ZipDocumentIdSource | ZipRequestIdSource;

export interface ZipRequestIdSource {
    'requestId': number;
    'zipFilename': string;
    'filename': string;
}

/**
 * AuthApi - axios parameter creator
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Issues a long-term token (e.g., 30-90 days) for automation or server-to-server use. Requires step-up authentication. Choose one of the supported grant types:  - `client_credentials` + `client_secret` - `client_credentials` + one-time `otp_code` - `assertion` (e.g., signed JWT by your private key) - Or an existing short-term token with the `tokens:write` scope  Only one mechanism is required per call. 
         * @summary Issue or rotate a long-term token
         * @param {LongTokenRequest} longTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueLongTermToken: async (longTokenRequest: LongTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'longTokenRequest' is not null or undefined
            assertParamExists('issueLongTermToken', 'longTokenRequest', longTokenRequest)
            const localVarPath = `/auth/tokens/long`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ShortTokenAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "ShortTokenAuth", ["tokens:write"], configuration)

            // authentication ClientKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(longTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exchange a valid long-term token for a short-lived JWT (e.g., 15 minutes). The long-term token must be sent in the Authorization header as `Bearer <long_token>`. 
         * @summary Issue a short-term access token
         * @param {ShortTokenRequest} [shortTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueShortTermToken: async (shortTokenRequest?: ShortTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/tokens/short`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication LongTokenAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "LongTokenAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shortTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revokes a short- or long-term token by its `tokenId`. Idempotent.
         * @summary Revoke a token
         * @param {string} tokenId The token ID to revoke
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken: async (tokenId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('revokeToken', 'tokenId', tokenId)
            const localVarPath = `/auth/tokens/{tokenId}/revoke`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication LongTokenAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "LongTokenAuth", ["tokens:revoke"], configuration)

            // authentication ShortTokenAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "ShortTokenAuth", ["tokens:revoke"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Issues a long-term token (e.g., 30-90 days) for automation or server-to-server use. Requires step-up authentication. Choose one of the supported grant types:  - `client_credentials` + `client_secret` - `client_credentials` + one-time `otp_code` - `assertion` (e.g., signed JWT by your private key) - Or an existing short-term token with the `tokens:write` scope  Only one mechanism is required per call. 
         * @summary Issue or rotate a long-term token
         * @param {LongTokenRequest} longTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueLongTermToken(longTokenRequest: LongTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LongTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueLongTermToken(longTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.issueLongTermToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exchange a valid long-term token for a short-lived JWT (e.g., 15 minutes). The long-term token must be sent in the Authorization header as `Bearer <long_token>`. 
         * @summary Issue a short-term access token
         * @param {ShortTokenRequest} [shortTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueShortTermToken(shortTokenRequest?: ShortTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShortTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueShortTermToken(shortTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.issueShortTermToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revokes a short- or long-term token by its `tokenId`. Idempotent.
         * @summary Revoke a token
         * @param {string} tokenId The token ID to revoke
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeToken(tokenId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeToken(tokenId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.revokeToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Issues a long-term token (e.g., 30-90 days) for automation or server-to-server use. Requires step-up authentication. Choose one of the supported grant types:  - `client_credentials` + `client_secret` - `client_credentials` + one-time `otp_code` - `assertion` (e.g., signed JWT by your private key) - Or an existing short-term token with the `tokens:write` scope  Only one mechanism is required per call. 
         * @summary Issue or rotate a long-term token
         * @param {LongTokenRequest} longTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueLongTermToken(longTokenRequest: LongTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<LongTokenResponse> {
            return localVarFp.issueLongTermToken(longTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Exchange a valid long-term token for a short-lived JWT (e.g., 15 minutes). The long-term token must be sent in the Authorization header as `Bearer <long_token>`. 
         * @summary Issue a short-term access token
         * @param {ShortTokenRequest} [shortTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueShortTermToken(shortTokenRequest?: ShortTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<ShortTokenResponse> {
            return localVarFp.issueShortTermToken(shortTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Revokes a short- or long-term token by its `tokenId`. Idempotent.
         * @summary Revoke a token
         * @param {string} tokenId The token ID to revoke
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken(tokenId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.revokeToken(tokenId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /**
     * Issues a long-term token (e.g., 30-90 days) for automation or server-to-server use. Requires step-up authentication. Choose one of the supported grant types:  - `client_credentials` + `client_secret` - `client_credentials` + one-time `otp_code` - `assertion` (e.g., signed JWT by your private key) - Or an existing short-term token with the `tokens:write` scope  Only one mechanism is required per call. 
     * @summary Issue or rotate a long-term token
     * @param {LongTokenRequest} longTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public issueLongTermToken(longTokenRequest: LongTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).issueLongTermToken(longTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exchange a valid long-term token for a short-lived JWT (e.g., 15 minutes). The long-term token must be sent in the Authorization header as `Bearer <long_token>`. 
     * @summary Issue a short-term access token
     * @param {ShortTokenRequest} [shortTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public issueShortTermToken(shortTokenRequest?: ShortTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).issueShortTermToken(shortTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revokes a short- or long-term token by its `tokenId`. Idempotent.
     * @summary Revoke a token
     * @param {string} tokenId The token ID to revoke
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public revokeToken(tokenId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).revokeToken(tokenId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobsApi - axios parameter creator
 */
export const JobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Submits a mailing job (multi doc merge). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a multi doc merge job
         * @param {SubmitMultiDocMergeParams} submitMultiDocMergeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiDocMergeParams: async (submitMultiDocMergeParams: SubmitMultiDocMergeParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submitMultiDocMergeParams' is not null or undefined
            assertParamExists('submitMultiDocMergeParams', 'submitMultiDocMergeParams', submitMultiDocMergeParams)
            const localVarPath = `/jobs/submit/multi/doc/merge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitMultiDocMergeParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a mailing job (multi doc). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a multi doc job
         * @param {SubmitMultiDocParams} submitMultiDocParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiDocParams: async (submitMultiDocParams: SubmitMultiDocParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submitMultiDocParams' is not null or undefined
            assertParamExists('submitMultiDocParams', 'submitMultiDocParams', submitMultiDocParams)
            const localVarPath = `/jobs/submit/multi/doc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitMultiDocParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a mailing job (multi zip addressCapture). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a multi zip addressCapture job
         * @param {SubmitMultiZipAddressCaptureParams} submitMultiZipAddressCaptureParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiZipAddressCaptureParams: async (submitMultiZipAddressCaptureParams: SubmitMultiZipAddressCaptureParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submitMultiZipAddressCaptureParams' is not null or undefined
            assertParamExists('submitMultiZipAddressCaptureParams', 'submitMultiZipAddressCaptureParams', submitMultiZipAddressCaptureParams)
            const localVarPath = `/jobs/submit/multi/zip/addressCapture`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitMultiZipAddressCaptureParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a mailing job (multi zip). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a multi zip job
         * @param {SubmitMultiZipParams} submitMultiZipParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiZipParams: async (submitMultiZipParams: SubmitMultiZipParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submitMultiZipParams' is not null or undefined
            assertParamExists('submitMultiZipParams', 'submitMultiZipParams', submitMultiZipParams)
            const localVarPath = `/jobs/submit/multi/zip`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitMultiZipParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a mailing job (single doc). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a single doc job
         * @param {SubmitSingleDocParams} submitSingleDocParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSingleDocParams: async (submitSingleDocParams: SubmitSingleDocParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submitSingleDocParams' is not null or undefined
            assertParamExists('submitSingleDocParams', 'submitSingleDocParams', submitSingleDocParams)
            const localVarPath = `/jobs/submit/single/doc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitSingleDocParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a mailing job (single pdf addressCapture). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a single pdf addressCapture job
         * @param {SubmitSinglePdfAddressCaptureParams} submitSinglePdfAddressCaptureParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSinglePdfAddressCaptureParams: async (submitSinglePdfAddressCaptureParams: SubmitSinglePdfAddressCaptureParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submitSinglePdfAddressCaptureParams' is not null or undefined
            assertParamExists('submitSinglePdfAddressCaptureParams', 'submitSinglePdfAddressCaptureParams', submitSinglePdfAddressCaptureParams)
            const localVarPath = `/jobs/submit/single/pdf/addressCapture`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitSinglePdfAddressCaptureParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a mailing job (single pdf split addressCapture). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a single pdf split addressCapture job
         * @param {SubmitSinglePdfSplitAddressCaptureParams} submitSinglePdfSplitAddressCaptureParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSinglePdfSplitAddressCaptureParams: async (submitSinglePdfSplitAddressCaptureParams: SubmitSinglePdfSplitAddressCaptureParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submitSinglePdfSplitAddressCaptureParams' is not null or undefined
            assertParamExists('submitSinglePdfSplitAddressCaptureParams', 'submitSinglePdfSplitAddressCaptureParams', submitSinglePdfSplitAddressCaptureParams)
            const localVarPath = `/jobs/submit/single/pdf/split/addressCapture`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitSinglePdfSplitAddressCaptureParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a mailing job (single pdf split). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a single pdf split job
         * @param {SubmitSinglePdfSplitParams} submitSinglePdfSplitParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSinglePdfSplitParams: async (submitSinglePdfSplitParams: SubmitSinglePdfSplitParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submitSinglePdfSplitParams' is not null or undefined
            assertParamExists('submitSinglePdfSplitParams', 'submitSinglePdfSplitParams', submitSinglePdfSplitParams)
            const localVarPath = `/jobs/submit/single/pdf/split`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitSinglePdfSplitParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 */
export const JobsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobsApiAxiosParamCreator(configuration)
    return {
        /**
         * Submits a mailing job (multi doc merge). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a multi doc merge job
         * @param {SubmitMultiDocMergeParams} submitMultiDocMergeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitMultiDocMergeParams(submitMultiDocMergeParams: SubmitMultiDocMergeParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitMultiDocMergeParams(submitMultiDocMergeParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.submitMultiDocMergeParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submits a mailing job (multi doc). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a multi doc job
         * @param {SubmitMultiDocParams} submitMultiDocParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitMultiDocParams(submitMultiDocParams: SubmitMultiDocParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitMultiDocParams(submitMultiDocParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.submitMultiDocParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submits a mailing job (multi zip addressCapture). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a multi zip addressCapture job
         * @param {SubmitMultiZipAddressCaptureParams} submitMultiZipAddressCaptureParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitMultiZipAddressCaptureParams(submitMultiZipAddressCaptureParams: SubmitMultiZipAddressCaptureParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitMultiZipAddressCaptureParams(submitMultiZipAddressCaptureParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.submitMultiZipAddressCaptureParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submits a mailing job (multi zip). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a multi zip job
         * @param {SubmitMultiZipParams} submitMultiZipParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitMultiZipParams(submitMultiZipParams: SubmitMultiZipParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitMultiZipParams(submitMultiZipParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.submitMultiZipParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submits a mailing job (single doc). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a single doc job
         * @param {SubmitSingleDocParams} submitSingleDocParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitSingleDocParams(submitSingleDocParams: SubmitSingleDocParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitSingleDocParams(submitSingleDocParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.submitSingleDocParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submits a mailing job (single pdf addressCapture). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a single pdf addressCapture job
         * @param {SubmitSinglePdfAddressCaptureParams} submitSinglePdfAddressCaptureParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitSinglePdfAddressCaptureParams(submitSinglePdfAddressCaptureParams: SubmitSinglePdfAddressCaptureParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitSinglePdfAddressCaptureParams(submitSinglePdfAddressCaptureParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.submitSinglePdfAddressCaptureParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submits a mailing job (single pdf split addressCapture). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a single pdf split addressCapture job
         * @param {SubmitSinglePdfSplitAddressCaptureParams} submitSinglePdfSplitAddressCaptureParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitSinglePdfSplitAddressCaptureParams(submitSinglePdfSplitAddressCaptureParams: SubmitSinglePdfSplitAddressCaptureParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitSinglePdfSplitAddressCaptureParams(submitSinglePdfSplitAddressCaptureParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.submitSinglePdfSplitAddressCaptureParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submits a mailing job (single pdf split). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a single pdf split job
         * @param {SubmitSinglePdfSplitParams} submitSinglePdfSplitParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitSinglePdfSplitParams(submitSinglePdfSplitParams: SubmitSinglePdfSplitParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitSinglePdfSplitParams(submitSinglePdfSplitParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.submitSinglePdfSplitParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobsApi - factory interface
 */
export const JobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobsApiFp(configuration)
    return {
        /**
         * Submits a mailing job (multi doc merge). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a multi doc merge job
         * @param {SubmitMultiDocMergeParams} submitMultiDocMergeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiDocMergeParams(submitMultiDocMergeParams: SubmitMultiDocMergeParams, options?: RawAxiosRequestConfig): AxiosPromise<StandardResponse> {
            return localVarFp.submitMultiDocMergeParams(submitMultiDocMergeParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits a mailing job (multi doc). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a multi doc job
         * @param {SubmitMultiDocParams} submitMultiDocParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiDocParams(submitMultiDocParams: SubmitMultiDocParams, options?: RawAxiosRequestConfig): AxiosPromise<StandardResponse> {
            return localVarFp.submitMultiDocParams(submitMultiDocParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits a mailing job (multi zip addressCapture). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a multi zip addressCapture job
         * @param {SubmitMultiZipAddressCaptureParams} submitMultiZipAddressCaptureParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiZipAddressCaptureParams(submitMultiZipAddressCaptureParams: SubmitMultiZipAddressCaptureParams, options?: RawAxiosRequestConfig): AxiosPromise<StandardResponse> {
            return localVarFp.submitMultiZipAddressCaptureParams(submitMultiZipAddressCaptureParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits a mailing job (multi zip). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a multi zip job
         * @param {SubmitMultiZipParams} submitMultiZipParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiZipParams(submitMultiZipParams: SubmitMultiZipParams, options?: RawAxiosRequestConfig): AxiosPromise<StandardResponse> {
            return localVarFp.submitMultiZipParams(submitMultiZipParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits a mailing job (single doc). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a single doc job
         * @param {SubmitSingleDocParams} submitSingleDocParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSingleDocParams(submitSingleDocParams: SubmitSingleDocParams, options?: RawAxiosRequestConfig): AxiosPromise<StandardResponse> {
            return localVarFp.submitSingleDocParams(submitSingleDocParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits a mailing job (single pdf addressCapture). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a single pdf addressCapture job
         * @param {SubmitSinglePdfAddressCaptureParams} submitSinglePdfAddressCaptureParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSinglePdfAddressCaptureParams(submitSinglePdfAddressCaptureParams: SubmitSinglePdfAddressCaptureParams, options?: RawAxiosRequestConfig): AxiosPromise<StandardResponse> {
            return localVarFp.submitSinglePdfAddressCaptureParams(submitSinglePdfAddressCaptureParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits a mailing job (single pdf split addressCapture). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a single pdf split addressCapture job
         * @param {SubmitSinglePdfSplitAddressCaptureParams} submitSinglePdfSplitAddressCaptureParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSinglePdfSplitAddressCaptureParams(submitSinglePdfSplitAddressCaptureParams: SubmitSinglePdfSplitAddressCaptureParams, options?: RawAxiosRequestConfig): AxiosPromise<StandardResponse> {
            return localVarFp.submitSinglePdfSplitAddressCaptureParams(submitSinglePdfSplitAddressCaptureParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits a mailing job (single pdf split). The request body contains job parameters including document source, recipient address information, and payment details.
         * @summary Submit a single pdf split job
         * @param {SubmitSinglePdfSplitParams} submitSinglePdfSplitParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSinglePdfSplitParams(submitSinglePdfSplitParams: SubmitSinglePdfSplitParams, options?: RawAxiosRequestConfig): AxiosPromise<StandardResponse> {
            return localVarFp.submitSinglePdfSplitParams(submitSinglePdfSplitParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobsApi - object-oriented interface
 */
export class JobsApi extends BaseAPI {
    /**
     * Submits a mailing job (multi doc merge). The request body contains job parameters including document source, recipient address information, and payment details.
     * @summary Submit a multi doc merge job
     * @param {SubmitMultiDocMergeParams} submitMultiDocMergeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public submitMultiDocMergeParams(submitMultiDocMergeParams: SubmitMultiDocMergeParams, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).submitMultiDocMergeParams(submitMultiDocMergeParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submits a mailing job (multi doc). The request body contains job parameters including document source, recipient address information, and payment details.
     * @summary Submit a multi doc job
     * @param {SubmitMultiDocParams} submitMultiDocParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public submitMultiDocParams(submitMultiDocParams: SubmitMultiDocParams, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).submitMultiDocParams(submitMultiDocParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submits a mailing job (multi zip addressCapture). The request body contains job parameters including document source, recipient address information, and payment details.
     * @summary Submit a multi zip addressCapture job
     * @param {SubmitMultiZipAddressCaptureParams} submitMultiZipAddressCaptureParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public submitMultiZipAddressCaptureParams(submitMultiZipAddressCaptureParams: SubmitMultiZipAddressCaptureParams, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).submitMultiZipAddressCaptureParams(submitMultiZipAddressCaptureParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submits a mailing job (multi zip). The request body contains job parameters including document source, recipient address information, and payment details.
     * @summary Submit a multi zip job
     * @param {SubmitMultiZipParams} submitMultiZipParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public submitMultiZipParams(submitMultiZipParams: SubmitMultiZipParams, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).submitMultiZipParams(submitMultiZipParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submits a mailing job (single doc). The request body contains job parameters including document source, recipient address information, and payment details.
     * @summary Submit a single doc job
     * @param {SubmitSingleDocParams} submitSingleDocParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public submitSingleDocParams(submitSingleDocParams: SubmitSingleDocParams, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).submitSingleDocParams(submitSingleDocParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submits a mailing job (single pdf addressCapture). The request body contains job parameters including document source, recipient address information, and payment details.
     * @summary Submit a single pdf addressCapture job
     * @param {SubmitSinglePdfAddressCaptureParams} submitSinglePdfAddressCaptureParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public submitSinglePdfAddressCaptureParams(submitSinglePdfAddressCaptureParams: SubmitSinglePdfAddressCaptureParams, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).submitSinglePdfAddressCaptureParams(submitSinglePdfAddressCaptureParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submits a mailing job (single pdf split addressCapture). The request body contains job parameters including document source, recipient address information, and payment details.
     * @summary Submit a single pdf split addressCapture job
     * @param {SubmitSinglePdfSplitAddressCaptureParams} submitSinglePdfSplitAddressCaptureParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public submitSinglePdfSplitAddressCaptureParams(submitSinglePdfSplitAddressCaptureParams: SubmitSinglePdfSplitAddressCaptureParams, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).submitSinglePdfSplitAddressCaptureParams(submitSinglePdfSplitAddressCaptureParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submits a mailing job (single pdf split). The request body contains job parameters including document source, recipient address information, and payment details.
     * @summary Submit a single pdf split job
     * @param {SubmitSinglePdfSplitParams} submitSinglePdfSplitParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public submitSinglePdfSplitParams(submitSinglePdfSplitParams: SubmitSinglePdfSplitParams, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).submitSinglePdfSplitParams(submitSinglePdfSplitParams, options).then((request) => request(this.axios, this.basePath));
    }
}



